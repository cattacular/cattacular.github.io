---
layout: post
title: RPG Game
categories: Games JavaScript
---

A simple turn-based RPG with a top-down perspective and tile-based movement. Explore the world, encounter creatures, and battle them in turn-based combat!

## How to Play

- Use **WASD** or **Arrow Keys** to move your character
- Walk into creatures to start battles
- In battles, choose your actions from the menu
- Defeat creatures to gain experience and level up

<div id="game-container" style="width: 100%; max-width: 800px; margin: 0 auto; text-align: center;">
  <canvas id="gameCanvas" width="800" height="600" style="border: 2px solid #333; background: #87CEEB;"></canvas>
  <div id="ui-container" style="margin-top: 10px;">
    <div id="stats" style="display: inline-block; margin: 0 20px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
      <strong>Player Stats:</strong><br>
      HP: <span id="player-hp">100</span>/<span id="player-max-hp">100</span><br>
      Level: <span id="player-level">1</span><br>
      XP: <span id="player-xp">0</span>
    </div>
    <div id="battle-ui" style="display: none; margin-top: 10px; padding: 10px; background: #ffebee; border-radius: 5px;">
      <div id="battle-text" style="margin-bottom: 10px;"></div>
      <button id="attack-btn" onclick="attack()">Attack</button>
      <button id="heal-btn" onclick="heal()">Heal</button>
      <button id="run-btn" onclick="run()">Run</button>
    </div>
  </div>
</div>

<script>
// Sprite system
const sprites = {
  player: null,
  goblin: null,
  orc: null,
  troll: null,
  grass: null,
  water: null,
  mountain: null
};

// Load all sprites
function loadSprites() {
  return new Promise((resolve) => {
    let loadedCount = 0;
    const totalSprites = 7;
    
    function onSpriteLoad() {
      loadedCount++;
      if (loadedCount === totalSprites) {
        resolve();
      }
    }
    
    // Create sprite images
    sprites.player = new Image();
    sprites.player.onload = onSpriteLoad;
    sprites.player.src = 'assets/images/game-assets/Player.png';
    
    sprites.goblin = new Image();
    sprites.goblin.onload = onSpriteLoad;
    sprites.goblin.src = 'assets/images/game-assets/Goblin1.png';
    
    sprites.orc = new Image();
    sprites.orc.onload = onSpriteLoad;
    sprites.orc.src = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
        <circle cx="15" cy="15" r="12" fill="#654321" stroke="#333" stroke-width="2"/>
        <circle cx="12" cy="12" r="2" fill="#FFD700"/>
        <circle cx="18" cy="12" r="2" fill="#FFD700"/>
        <path d="M 12 18 Q 15 20 18 18" stroke="#FFD700" stroke-width="2" fill="none"/>
        <rect x="13" y="22" width="4" height="6" fill="#8B4513"/>
        <polygon points="15,6 12,10 18,10" fill="#2F4F2F"/>
      </svg>
    `);
    
    sprites.troll = new Image();
    sprites.troll.onload = onSpriteLoad;
    sprites.troll.src = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
        <circle cx="15" cy="15" r="12" fill="#556B2F" stroke="#333" stroke-width="2"/>
        <circle cx="12" cy="12" r="2" fill="#FFD700"/>
        <circle cx="18" cy="12" r="2" fill="#FFD700"/>
        <path d="M 12 18 Q 15 20 18 18" stroke="#FFD700" stroke-width="2" fill="none"/>
        <rect x="13" y="22" width="4" height="6" fill="#8B7355"/>
        <polygon points="15,6 12,10 18,10" fill="#4B0082"/>
      </svg>
    `);
    
    sprites.grass = new Image();
    sprites.grass.onload = onSpriteLoad;
    sprites.grass.src = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
        <rect width="30" height="30" fill="#90EE90"/>
        <circle cx="8" cy="8" r="1" fill="#228B22"/>
        <circle cx="22" cy="12" r="1" fill="#228B22"/>
        <circle cx="15" cy="20" r="1" fill="#228B22"/>
        <circle cx="5" cy="18" r="1" fill="#228B22"/>
        <circle cx="25" cy="6" r="1" fill="#228B22"/>
      </svg>
    `);
    
    sprites.water = new Image();
    sprites.water.onload = onSpriteLoad;
    sprites.water.src = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
        <rect width="30" height="30" fill="#4682B4"/>
        <path d="M 0 10 Q 7.5 5 15 10 Q 22.5 15 30 10" stroke="#87CEEB" stroke-width="2" fill="none"/>
        <path d="M 0 20 Q 7.5 15 15 20 Q 22.5 25 30 20" stroke="#87CEEB" stroke-width="2" fill="none"/>
      </svg>
    `);
    
    sprites.mountain = new Image();
    sprites.mountain.onload = onSpriteLoad;
    sprites.mountain.src = 'data:image/svg+xml;base64,' + btoa(`
      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
        <rect width="30" height="30" fill="#8B4513"/>
        <polygon points="0,30 15,10 30,30" fill="#A0522D"/>
        <polygon points="5,30 15,15 25,30" fill="#CD853F"/>
      </svg>
    `);
  });
}

// Game state
const gameState = {
  player: {
    x: 5,
    y: 5,
    hp: 100,
    maxHp: 100,
    level: 1,
    xp: 0,
    attack: 15,
    defense: 10
  },
  creatures: [
    { x: 8, y: 8, hp: 50, maxHp: 50, attack: 10, defense: 5, name: "Goblin", xpReward: 20, type: "goblin" },
    { x: 12, y: 12, hp: 80, maxHp: 80, attack: 15, defense: 8, name: "Orc", xpReward: 35, type: "orc" },
    { x: 15, y: 6, hp: 60, maxHp: 60, attack: 12, defense: 6, name: "Troll", xpReward: 25, type: "troll" }
  ],
  inBattle: false,
  currentEnemy: null,
  map: []
};

// Tile types
const TILES = {
  GRASS: 0,
  WATER: 1,
  MOUNTAIN: 2
};

// Colors for tiles
const TILE_COLORS = {
  [TILES.GRASS]: '#90EE90',
  [TILES.WATER]: '#4682B4',
  [TILES.MOUNTAIN]: '#8B4513'
};

// Initialize map
function initMap() {
  const mapSize = 20;
  gameState.map = [];
  
  for (let y = 0; y < mapSize; y++) {
    gameState.map[y] = [];
    for (let x = 0; x < mapSize; x++) {
      // Create a simple map with grass, some water, and mountains
      if (x === 0 || y === 0 || x === mapSize - 1 || y === mapSize - 1) {
        gameState.map[y][x] = TILES.MOUNTAIN; // Border
      } else if (Math.random() < 0.1) {
        gameState.map[y][x] = TILES.WATER;
      } else {
        gameState.map[y][x] = TILES.GRASS;
      }
    }
  }
}

// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 30;

// Draw functions
function drawMap() {
  for (let y = 0; y < gameState.map.length; y++) {
    for (let x = 0; x < gameState.map[y].length; x++) {
      const tile = gameState.map[y][x];
      let sprite;
      
      switch(tile) {
        case TILES.GRASS:
          sprite = sprites.grass;
          break;
        case TILES.WATER:
          sprite = sprites.water;
          break;
        case TILES.MOUNTAIN:
          sprite = sprites.mountain;
          break;
        default:
          sprite = sprites.grass;
      }
      
      if (sprite) {
        ctx.drawImage(sprite, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}

function drawPlayer() {
  if (sprites.player) {
    ctx.drawImage(
      sprites.player,
      gameState.player.x * TILE_SIZE,
      gameState.player.y * TILE_SIZE,
      TILE_SIZE,
      TILE_SIZE
    );
  }
}

function drawCreatures() {
  gameState.creatures.forEach(creature => {
    if (creature.hp > 0 && sprites[creature.type]) {
      ctx.drawImage(
        sprites[creature.type],
        creature.x * TILE_SIZE,
        creature.y * TILE_SIZE,
        TILE_SIZE,
        TILE_SIZE
      );
    }
  });
}

function drawUI() {
  // Draw camera offset to center on player
  const cameraX = Math.max(0, Math.min(gameState.player.x - 10, gameState.map[0].length - 20));
  const cameraY = Math.max(0, Math.min(gameState.player.y - 8, gameState.map.length - 16));
  
  ctx.save();
  ctx.translate(-cameraX * TILE_SIZE, -cameraY * TILE_SIZE);
  
  drawMap();
  drawCreatures();
  drawPlayer();
  
  ctx.restore();
}

// Movement
function canMoveTo(x, y) {
  if (x < 0 || y < 0 || x >= gameState.map[0].length || y >= gameState.map.length) {
    return false;
  }
  return gameState.map[y][x] !== TILES.MOUNTAIN && gameState.map[y][x] !== TILES.WATER;
}

function movePlayer(dx, dy) {
  if (gameState.inBattle) return;
  
  const newX = gameState.player.x + dx;
  const newY = gameState.player.y + dy;
  
  if (canMoveTo(newX, newY)) {
    gameState.player.x = newX;
    gameState.player.y = newY;
    
    // Check for creature encounters
    checkForEncounters();
  }
}

function checkForEncounters() {
  const creature = gameState.creatures.find(c => 
    c.hp > 0 && c.x === gameState.player.x && c.y === gameState.player.y
  );
  
  if (creature) {
    startBattle(creature);
  }
}

// Battle system
function startBattle(enemy) {
  gameState.inBattle = true;
  gameState.currentEnemy = enemy;
  
  document.getElementById('battle-ui').style.display = 'block';
  document.getElementById('battle-text').textContent = `A wild ${enemy.name} appears!`;
  
  updateStats();
}

function attack() {
  if (!gameState.inBattle || !gameState.currentEnemy) return;
  
  const enemy = gameState.currentEnemy;
  const damage = Math.max(1, gameState.player.attack - enemy.defense);
  enemy.hp = Math.max(0, enemy.hp - damage);
  
  document.getElementById('battle-text').textContent = `You deal ${damage} damage to ${enemy.name}!`;
  
  if (enemy.hp <= 0) {
    endBattle(true);
  } else {
    // Enemy attacks back
    setTimeout(() => {
      enemyAttack();
    }, 1000);
  }
}

function enemyAttack() {
  if (!gameState.inBattle || !gameState.currentEnemy) return;
  
  const enemy = gameState.currentEnemy;
  const damage = Math.max(1, enemy.attack - gameState.player.defense);
  gameState.player.hp = Math.max(0, gameState.player.hp - damage);
  
  document.getElementById('battle-text').textContent = `${enemy.name} deals ${damage} damage to you!`;
  updateStats();
  
  if (gameState.player.hp <= 0) {
    endBattle(false);
  }
}

function heal() {
  if (!gameState.inBattle) return;
  
  const healAmount = 30;
  gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
  
  document.getElementById('battle-text').textContent = `You heal for ${healAmount} HP!`;
  updateStats();
  
  // Enemy attacks after healing
  setTimeout(() => {
    enemyAttack();
  }, 1000);
}

function run() {
  if (!gameState.inBattle) return;
  
  const success = Math.random() > 0.5;
  if (success) {
    document.getElementById('battle-text').textContent = "You successfully ran away!";
    setTimeout(() => {
      endBattle(false);
    }, 1000);
  } else {
    document.getElementById('battle-text').textContent = "You couldn't escape!";
    setTimeout(() => {
      enemyAttack();
    }, 1000);
  }
}

function endBattle(playerWon) {
  if (playerWon) {
    const xpGained = gameState.currentEnemy.xpReward;
    gameState.player.xp += xpGained;
    
    document.getElementById('battle-text').textContent = 
      `You defeated ${gameState.currentEnemy.name}! Gained ${xpGained} XP!`;
    
    // Check for level up
    const xpNeeded = gameState.player.level * 50;
    if (gameState.player.xp >= xpNeeded) {
      levelUp();
    }
  } else {
    document.getElementById('battle-text').textContent = "You were defeated!";
    // Reset player position
    gameState.player.x = 5;
    gameState.player.y = 5;
    gameState.player.hp = gameState.player.maxHp;
  }
  
  setTimeout(() => {
    gameState.inBattle = false;
    gameState.currentEnemy = null;
    document.getElementById('battle-ui').style.display = 'none';
    updateStats();
  }, 2000);
}

function levelUp() {
  gameState.player.level++;
  gameState.player.maxHp += 20;
  gameState.player.hp = gameState.player.maxHp;
  gameState.player.attack += 5;
  gameState.player.defense += 3;
  
  document.getElementById('battle-text').textContent += ` Level up! You are now level ${gameState.player.level}!`;
}

function updateStats() {
  document.getElementById('player-hp').textContent = gameState.player.hp;
  document.getElementById('player-max-hp').textContent = gameState.player.maxHp;
  document.getElementById('player-level').textContent = gameState.player.level;
  document.getElementById('player-xp').textContent = gameState.player.xp;
}

// Input handling
document.addEventListener('keydown', (e) => {
  switch(e.key.toLowerCase()) {
    case 'w':
    case 'arrowup':
      movePlayer(0, -1);
      break;
    case 's':
    case 'arrowdown':
      movePlayer(0, 1);
      break;
    case 'a':
    case 'arrowleft':
      movePlayer(-1, 0);
      break;
    case 'd':
    case 'arrowright':
      movePlayer(1, 0);
      break;
  }
});

// Game loop
function gameLoop() {
  drawUI();
  requestAnimationFrame(gameLoop);
}

// Initialize and start
async function initGame() {
  await loadSprites();
  initMap();
  updateStats();
  gameLoop();
}

initGame();
</script>

## Game Features

- **Top-down perspective** with tile-based movement
- **Turn-based combat system** with attack, heal, and run options
- **Experience and leveling system**
- **Multiple enemy types** with different stats
- **Simple but functional UI** showing player stats and battle options

## Controls

- **WASD** or **Arrow Keys**: Move your character
- **Mouse**: Click battle buttons during encounters

The game includes a simple map with grass, water, and mountain tiles. Walk around to find creatures and battle them to gain experience and level up!

## Customizing Sprites

The game now uses a sprite system that makes it easy to replace the default graphics with your own images. Here's how to customize the sprites:

### Method 1: Replace with Image URLs

To use your own images, replace the sprite loading code with URLs to your images:

```javascript
// Replace the sprite loading in the loadSprites() function
sprites.player = new Image();
sprites.player.onload = onSpriteLoad;
sprites.player.src = 'https://your-domain.com/path/to/player-sprite.png';

sprites.goblin = new Image();
sprites.goblin.onload = onSpriteLoad;
sprites.goblin.src = 'https://your-domain.com/path/to/goblin-sprite.png';
```

### Method 2: Use Local Images

If you have images in your Jekyll assets folder:

```javascript
sprites.player.src = '{{ site.baseurl }}/assets/images/player-sprite.png';
sprites.goblin.src = '{{ site.baseurl }}/assets/images/goblin-sprite.png';
```

### Method 3: Create Custom SVG Sprites

You can modify the existing SVG sprites by editing the SVG code in the `loadSprites()` function. Each sprite is defined as an SVG string that gets converted to a data URL.

### Sprite Requirements

- **Size**: 30x30 pixels (or maintain aspect ratio)
- **Format**: PNG, JPG, or SVG
- **Transparency**: PNG with alpha channel works best
- **Style**: Pixel art or cartoon style works well for this type of game

### Available Sprites to Replace

- `sprites.player` - The player character
- `sprites.goblin` - Goblin enemy
- `sprites.orc` - Orc enemy  
- `sprites.troll` - Troll enemy
- `sprites.grass` - Grass tile texture
- `sprites.water` - Water tile texture
- `sprites.mountain` - Mountain tile texture

The current sprites are embedded SVG graphics that provide a good starting point, but you can replace them with any images you prefer!
